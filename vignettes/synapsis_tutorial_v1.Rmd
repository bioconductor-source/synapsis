---
title: "Using synapsis"
author: "Lucy McNeill"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{synapsis_tutorial_v1}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(synapsis)
library(knitr)
library(rmarkdown)
library(tidyverse)
library(ggplot2)
```

# Getting started

## installing library from gitlab

To use synapsis, you will need the following packages:

- stats
- EBImage
- graphics
- utils

And to run this tutorial, you will need:

- tidyverse
- ggplot2
- knitr
- rmarkdown


```{r, eval = FALSE}
devtools::install_git('https://gitlab.svi.edu.au/lmcneill/synapsis')
```

## loading synapsis

```{r}
library(synapsis)
library(EBImage)
```
## checking documentation

## Data preparation

For the moment, we will use the example images which come with synapsis.

```{r}
path = paste0(system.file("extdata",package = "synapsis"))
```

## Quick look at data with EBImage

The example images are from the same slide. One of them "-RGB" is a false colour three channel image. The other three are the single channels corresponding to specific antibodies or stains. For now, we will take a look at the sample image
```{r}
file_3channel <- paste0(path,"/MLH3rabbit488_SYCP3mouse594_fancm_fvb_x_fancm_bl6_724++_slide01_006-RGB.jpeg")
image_3channel <- readImage(file_3channel)
display(image_3channel)
```
After a look at the image, we note that SYCP3 and MLH3 antibodies illuminate synaptonemal complexes (red) and foci (green) respectively. DAPI stains cells (blue). In functions, channel1_string refers to the antibody/ identifier for the *foci* channel (green here). It defaults to \*-MLH3. channel2_string is the antibody/ identifier for the *synaptonemal complex / dna* channel (red here), which defaults to \*-SYCP3. channel3_string is optional antibody/ identifier for a third channel. It defaults to \*DAPI. We can split these up

```{r}
r = channel(image_3channel,"r")
g = channel(image_3channel,"g")
b = channel(image_3channel,"b")
```
Let's confirm that this is consistent with our filenames.

### MLH3 channel
```{r}
display(g)
```
Now compare to the file ending in MLH3
```{r}
file_MLH3 <- paste0(path,"/MLH3rabbit488_SYCP3mouse594_fancm_fvb_x_fancm_bl6_724++_slide01_006-MLH3.jpeg")
image_MLH3 <- readImage(file_MLH3)
display(image_MLH3)
```
They should be the same.

### SYCP3 channel
```{r}
display(r)
```
Now compare to the file ending in SYCP3
```{r}
file_SYCP3 <- paste0(path,"/MLH3rabbit488_SYCP3mouse594_fancm_fvb_x_fancm_bl6_724++_slide01_006-SYCP3.jpeg")
image_SYCP3 <- readImage(file_SYCP3)
display(image_SYCP3)
```
That is a short introduction to the file naming convention in synapsis. We will go into more detail at the end of the tutorial, particularly what this means for your dataset.

### DAPI channel (optional)

And DAPI channel
```{r}
display(b)
```
Now compare to the file ending in SYCP3
```{r}
file_DAPI <- paste0(path,"/MLH3rabbit488_SYCP3mouse594_fancm_fvb_x_fancm_bl6_724++_slide01_006-DAPI.jpeg")
image_DAPI <- readImage(file_DAPI)
display(image_DAPI)
```

# Calling functions on data

## Cropping routine

You can type 
```{r,  eval = FALSE}
??auto_crop_fast
```
There is an annotation setting, which we switch to "on".  max_cell_area and  min_cell_area have been calibrated to our data set, where the subject are mouse cells and magnification kept constant. You could run it on the first five images by setting e.g. test_amount = 5. But for now we will just look at the single image.
```{r}
auto_crop_fast(path, annotation = "on", max_cell_area = 30000, min_cell_area = 7000, test_amount = 1)
```
Here we called path, plus other optional parameters (that would otherwise take on default values). But only path is essential. This is because auto_crop_fast has built-in default values which are assumed when the user doesn't specify.

A crops folder with three channels per "viable cell" should have been generated inside the folder where these images are kept i.e. in path.

## Getting pachytene 

```{r}
SYCP3_stats <- get_pachytene(path,ecc_thresh = 0.8, area_thresh = 0.04, annotation = "on")
```
SYCP3_stats is a data frame summarizing some features of the cells classified as pachytene.
## Counting foci 
```{r}
foci_counts <- count_foci(path,offset_factor = 3, brush_size = 3, brush_sigma = 3, annotation = "on",stage = "pachytene")
```
foci_counts is a data frame summarizing some features (including foci counts) of the cells classified as pachytene.

## Distance between foci on SC
```{r}
df_dist <- measure_distances(path, annotation = "on")
```

# Bigger data set

Now we will run auto_crop on the bigger data set (silently/ without annotation) to do some significance testing. 
```{r, eval = FALSE}
start_time <- as.numeric(as.numeric(Sys.time())*1000, digits=15) # place at start
auto_crop_fast(path, annotation = "off", max_cell_area = 30000, min_cell_area = 7000,third_channel = "on")
end_time <- as.numeric(as.numeric(Sys.time())*1000, digits=15)
print(end_time - start_time)
```

## Counting foci

Now let's count the foci for each genotype.

```{r, eval = FALSE}
SYCP3_stats <- get_pachytene(path,ecc_thresh = 0.8, area_thresh = 0.04, annotation = "off")
foci_counts <- count_foci(path,offset_factor = 3, brush_size = 3, brush_sigma = 3, annotation = "off",stage = "pachytene")
```
Instead of evaluating, we will load the resulting dataframe from executing the above chunk on a large dataset. In this example data set (images taken by Vanessa Tsui in 2020 at SVI), there are 174 images where auto_crop_fast yields 243 crops. This took 1.2 minutes.

# Statistics

## loading files
```{r}
demo_path <-paste0(system.file("extdata",package = "synapsis"),"/")
foci_count_path <- paste0(demo_path, "df_foci_count.csv")
foci_counts <- read.csv(foci_count_path)
```
## Some statistics 
```{r}
### comparing groups
counts <- foci_counts$foci_count
counts_mod <- foci_counts[as.numeric(foci_counts$foci_count) > 0,]
counts_mod <- foci_counts[as.numeric(foci_counts$foci_count) < 40,]
#counts_mod <- counts_mod[as.numeric(counts_mod$percent_on) > 0.55,]
# counts_mod <- counts_mod[as.numeric(counts_mod$sd_foci) <20,]
counts <- counts_mod$foci_count
counts_KO <- counts_mod[counts_mod$genotype == "Fancm-/-",]
counts_WT <- counts_mod[counts_mod$genotype == "Fancm+/+",]

count_KO <- counts_KO$foci_count
count_WT <- counts_WT$foci_count
mean(as.numeric(count_KO), na.rm= TRUE)
mean(as.numeric(count_WT), na.rm= TRUE)
sd(as.numeric(count_KO), na.rm= TRUE)
sd(as.numeric(count_WT), na.rm= TRUE)

c1 <- rgb(173,216,230,max = 255, alpha = 140, names = "lt.blue")
c4 <- rgb(255,180,50, max = 255, alpha = 120, names = "lt.orange")
A <- hist(as.numeric(count_WT),plot = FALSE)
B <-  hist(as.numeric(count_KO), plot = FALSE )
plot(A,ylim = c(0,20),  main = "Pachytene", col = c4, xlab = "foci count per cell") 
plot(B, col = c1, add = TRUE) 
```

## comparison testing

### anova test
```{r}
## anova test
counts_mod$group <- factor(counts_mod$genotype, c("Fancm-/-", "Fancm+/+"))
outfit <- lm(foci_count ~ genotype, data=counts_mod)
outfit
#df.residual(outfit)
#sigma(outfit)
#model.matrix(outfit)
outfit0 <- lm(foci_count ~ 1, data=counts_mod)
anova(outfit0, outfit)
```
 
### t test
```{r}
t.test(as.numeric(count_KO),as.numeric(count_WT))
```
now that we have a p value we can paste this on the histogram 
```{r, eval = FALSE}
c1 <- rgb(173,216,230,max = 255, alpha = 140, names = "lt.blue")
c4 <- rgb(255,180,50, max = 255, alpha = 120, names = "lt.orange")
A <- hist(as.numeric(count_WT),plot = FALSE)
B <-  hist(as.numeric(count_KO), plot = FALSE )
plot(A,ylim = c(0,20),  main = "Pachytene", col = c4, xlab = "foci count per cell") 
text(x = 10, y = 15, label = "anova p value = 0.01*", col = "black", cex = 1)
plot(B, col = c1, add = TRUE) 
```

### Boxplot
```{r}
library(tidyverse)
counts_mod %>% 
  ggplot(aes(x=genotype, y=as.numeric(foci_count), fill = genotype)) + 
  geom_boxplot(width=0.5,lwd=1.5) + 
  geom_jitter(width=0.15) + 
  labs(subtitle="MLH3 foci counts")
```

## Measuring distances
We can also get some stats on the distances measured.
```{r}
distances_path <- paste0(demo_path, "df_distances.csv")
df_dist <- read.csv(distances_path)
pass_only <- df_dist[df_dist$pass_fail == "pass",]
distances <- pass_only$fractional_distance
distances_KO <- pass_only[pass_only$genotype == "Fancm-/-",]
distances_WT <- pass_only[pass_only$genotype == "Fancm+/+",]

distance_KO <- distances_KO$fractional_distance
distance_WT <- distances_WT$fractional_distance
mean(as.numeric(distance_KO), na.rm= TRUE)
mean(as.numeric(distance_WT), na.rm= TRUE)
sd(as.numeric(distance_KO), na.rm= TRUE)
sd(as.numeric(distance_WT), na.rm= TRUE)

c1 <- rgb(173,216,230,max = 255, alpha = 140, names = "lt.blue")
c4 <- rgb(255,180,50, max = 255, alpha = 120, names = "lt.orange")
A <- hist(as.numeric(distance_WT),plot = FALSE)
B <-  hist(as.numeric(distance_KO), plot = FALSE )
plot(A,ylim = c(0,9),xlim = c(0,1),  main = "Pachytene", col = c4, xlab = "foci distance as fraction of total length") 
#text(x = 0.2, y = 7, label = "anova p value 0.9 (NS)", col = "black", cex = 1)
plot(B, col = c1, add = TRUE) 
```
```{r}
t.test(as.numeric(distance_KO),as.numeric(distance_WT))
```


# Running on your own data

## .nd2 files

## 3 channel / false colour jpeg, tiff or pngs

